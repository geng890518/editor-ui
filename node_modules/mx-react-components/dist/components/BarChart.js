'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var numeral = require('numeral');
var _isEqual = require('lodash/isEqual');

var StyleConstants = require('../constants/Style');

var SetIntervalMixin = {
  componentWillMount: function componentWillMount() {
    this.intervals = [];
  },
  setInterval: function (_setInterval) {
    function setInterval() {
      return _setInterval.apply(this, arguments);
    }

    setInterval.toString = function () {
      return _setInterval.toString();
    };

    return setInterval;
  }(function () {
    this.intervals.push(setInterval.apply(null, arguments));
  }),
  componentWillUnmount: function componentWillUnmount() {
    this.intervals.map(clearInterval);
  }
};

var Rect = React.createClass({
  displayName: 'Rect',

  propTypes: {
    animateOnHover: React.PropTypes.bool,
    color: React.PropTypes.string,
    height: React.PropTypes.number.isRequired,
    label: React.PropTypes.string,
    onClick: React.PropTypes.func,
    onMouseOut: React.PropTypes.func,
    onMouseOver: React.PropTypes.func,
    primaryColor: React.PropTypes.string,
    value: React.PropTypes.number.isRequired,
    width: React.PropTypes.number,
    x: React.PropTypes.number.isRequired,
    y: React.PropTypes.number.isRequired
  },

  mixins: [SetIntervalMixin],

  getInitialState: function getInitialState() {
    return {
      hovering: false,
      milliseconds: 0
    };
  },
  componentDidMount: function componentDidMount() {
    this.setInterval(this.tick, 10);
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (nextProps.value !== this.props.value) {
      this.setState({
        milliseconds: 0
      });
    }
  },
  tick: function tick() {
    this.setState({
      milliseconds: this.state.milliseconds + 10
    });
  },
  _handleMouseOver: function _handleMouseOver(label, value, x, y) {
    var animateDuration = 500;

    this.setState({
      hovering: true,
      milliseconds: this.props.animateOnHover ? animateDuration : this.state.milliseconds
    });

    this.props.onMouseOver(label, value, x, y);
  },
  _handleMouseOut: function _handleMouseOut() {
    this.setState({
      hovering: false
    });

    this.props.onMouseOut();
  },
  render: function render() {
    var animateHeight = d3.ease('back-out', 0.5);
    var height = this.props.height * animateHeight(Math.min(1, this.state.milliseconds / 1000));
    var y = this.props.height - height + this.props.y;
    var shift = this.props.value > 0 ? '3px' : '-3px';
    var style = {
      fill: this.state.hovering && this.props.primaryColor ? this.props.primaryColor : this.props.color,
      cursor: 'pointer',
      transform: 'translateY(' + shift + ')'
    };

    return React.createElement('rect', {
      height: height,
      onClick: this.props.onClick.bind(null, this.props.value, this.props.label),
      onMouseOut: this._handleMouseOut,
      onMouseOver: this._handleMouseOver.bind(null, this.props.label, this.props.value, this.props.x, y),
      rx: 3,
      ry: 3,
      style: style,
      width: this.props.width,
      x: this.props.x,
      y: y
    });
  }
});

var BarChart = React.createClass({
  displayName: 'BarChart',

  propTypes: {
    animateOnHover: React.PropTypes.bool,
    data: React.PropTypes.array.isRequired,
    height: React.PropTypes.number,
    labelStyle: React.PropTypes.object,
    onClick: React.PropTypes.func,
    onHover: React.PropTypes.func,
    primaryColor: React.PropTypes.string,
    tooltipFormat: React.PropTypes.string,
    tooltipStyle: React.PropTypes.object,
    width: React.PropTypes.number
  },

  getDefaultProps: function getDefaultProps() {
    return {
      animateOnHover: false,
      height: 300,
      onClick: function onClick() {},
      onHover: function onHover() {},
      primaryColor: StyleConstants.Colors.PRIMARY,
      tooltipFormat: '$0,0.00',
      width: 500
    };
  },
  getInitialState: function getInitialState() {
    return {
      hovering: false
    };
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return !_isEqual(nextProps, this.props) || !_isEqual(nextState, this.state);
  },
  _handleMouseOver: function _handleMouseOver(label, value, x, y) {
    this.setState({
      hovering: true,
      value: value,
      x: x,
      y: y
    });
  },
  _handleMouseOut: function _handleMouseOut() {
    this.setState({
      hovering: false
    });
  },
  _renderLabels: function _renderLabels(barWidth, xScale) {
    var _this = this;

    var styles = this.styles();

    return this.props.data.map(function (item, index) {
      var xPos = xScale(index);
      var labelPos = {
        position: 'absolute',
        left: xPos,
        width: barWidth
      };

      return React.createElement(
        'span',
        {
          key: index,
          style: _extends({}, styles.label, labelPos, _this.props.labelStyle)
        },
        item.label
      );
    });
  },
  _renderBar: function _renderBar(yScale, xScale, barWidth, value, index) {
    var height = value < 0 ? Math.abs(yScale(value) - yScale(0)) : yScale(value);
    var x = xScale(index);
    var y = value > 0 ? this.props.height - height : 0;

    return React.createElement(Rect, {
      animateOnHover: this.props.animateOnHover,
      color: this.props.data[index].color,
      height: height,
      key: index * value,
      label: this.props.data[index].label,
      onClick: this.props.onClick,
      onMouseOut: this._handleMouseOut,
      onMouseOver: this._handleMouseOver,
      primaryColor: this.props.primaryColor,
      value: value,
      width: barWidth,
      x: x,
      y: y
    });
  },
  render: function render() {
    var _this2 = this;

    var styles = this.styles();
    var _props = this.props;
    var height = _props.height;
    var width = _props.width;

    var data = this.props.data.map(function (d) {
      return d.value;
    });
    var gap = 0.3;
    var y0 = Math.max(Math.abs(d3.min(data)), Math.abs(d3.max(data)));

    var yScale = d3.scale.linear().domain([-y0, y0]).range([0, height]);

    var xScale = d3.scale.ordinal().domain(d3.range(this.props.data.length)).rangeRoundBands([0, width], gap);

    var barWidth = xScale.rangeBand();

    var positiveBars = data.map(function (value, index) {
      return value > 0 ? _this2._renderBar(yScale, xScale, barWidth, value, index) : null;
    });

    var negativeBars = data.map(function (value, index) {
      return value < 0 ? _this2._renderBar(yScale, xScale, barWidth, value, index) : null;
    });

    var maxHeightForPositiveBars = d3.max(data) > 0 ? yScale(d3.max(data)) : 0;
    var maxHeightForNegativeBars = d3.min(data) < 0 ? yScale(Math.abs(d3.min(data))) - yScale(0) : 0;
    var tooltipMargin = 20;
    var tooltipWidth = barWidth * 1.5;
    var tooltipXPos = (tooltipWidth - barWidth) / 2;
    var tooltipYPos = maxHeightForPositiveBars > 0 ? maxHeightForPositiveBars - tooltipMargin : -1 * tooltipMargin;
    var tooltipStyle = {
      left: this.state.x - tooltipXPos,
      top: this.state.value > 0 ? this.state.y - tooltipMargin : tooltipYPos,
      width: tooltipWidth
    };

    return React.createElement(
      'div',
      { style: _extends({}, styles.component, this.props.style) },
      React.createElement(
        'svg',
        { height: maxHeightForPositiveBars, width: width },
        positiveBars
      ),
      React.createElement(
        'svg',
        { height: maxHeightForNegativeBars, width: width },
        React.createElement(
          'g',
          null,
          negativeBars
        )
      ),
      React.createElement(
        'div',
        null,
        this._renderLabels(barWidth, xScale)
      ),
      this.state.hovering ? React.createElement(
        'span',
        { style: _extends({}, styles.tooltip, tooltipStyle, this.props.tooltipStyle) },
        this.props.tooltipFormat ? numeral(this.state.value).format(this.props.tooltipFormat) : this.state.value
      ) : null
    );
  },
  styles: function styles() {
    return {
      component: {
        display: 'block',
        position: 'relative'
      },
      label: {
        color: StyleConstants.Colors.ASH,
        display: 'inline-block',
        fontSize: StyleConstants.FontSizes.SMALL,
        textAlign: 'center'
      },
      tooltip: {
        color: this.props.primaryColor,
        fontSize: StyleConstants.FontSizes.LARGE,
        fontFamily: StyleConstants.Fonts.SEMIBOLD,
        position: 'absolute',
        textAlign: 'center',
        whiteSpace: 'nowrap'
      }
    };
  }
});

module.exports = BarChart;